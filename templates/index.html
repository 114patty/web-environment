<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/luxon"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-luxon"></script>
    <link rel="stylesheet" href="/static/css/theme.css"> 
    <script src="/static/js/theme.js" defer></script>

                             
    <meta charset="UTF-8">              
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IMU å§¿æ…‹æ•¸æ“šç›£æ¸¬</title>                                                                                                                                       
                                                                                                                                                                                                
    <style>                                                                                                                                                                                                                                                                     
        :root {                   
            --theme-bg: #f6f3e8; /* ä¸»èƒŒæ™¯ */
            --theme-text: #333333; /* æ–‡å­— */
            --theme-tab-bg: #f6f3e8; /* åˆ†é èƒŒæ™¯ */
            --theme-tab-active-bg: #ffffff; /* é¸ä¸­åˆ†é èƒŒæ™¯ */
            --theme-container-bg: #ffffff;
            --theme-surface: #ffffff;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ;   /* ä¸»å®¹å™¨èƒŒæ™¯ï¼ˆå¦‚æ¡†æ¡†ï¼‰ */
            --theme-section: #fbf9f3;  /* å€å¡Šæˆ–è¡¨æ ¼å…§éƒ¨çš„åº•è‰² */
            --theme-table-header-bg: #fbf9f3;
            --theme-border: #b0a99f;
        }
        body { font-family: Arial, sans-serif;transition: margin-left 0.3s ease; margin: 20px; background-color: var(--theme-bg); color: var(--theme-text); }
        .container { max-width: 900px; margin: auto; background: var(--theme-surface);padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        h1 { text-align: center; color: var(--theme-heading); }

        /* å¤–æ¡†å®¹å™¨ */
        .dashboard-body {
            background-color: var(--theme-section);
            border-radius: 12px;
            padding: 24px;
            margin-top: -16px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.05);
            border: none; 
        }
        /* åˆ†é å®¹å™¨ */
        .data-section {
            padding: 0;
            border-radius: 0;
            box-shadow: none;
            border: none; 
        }

        table {
            width: auto;           /* æ ¹æ“šå…§å®¹è‡ªå‹•èª¿æ•´è¡¨æ ¼å¯¬åº¦ */
            max-width: 100%;       /* é¿å…è¶…å‡ºå®¹å™¨å¯¬åº¦ */
            table-layout: auto;    
            margin-bottom: 20px; /* Add some space below table */
        }
        /* å´é‚Šæ¬„æ¨£å¼ */
        #sidebar {
            position: fixed;
            top: 0;
            left: -200px; /* é è¨­éš±è— */
            width: 200px;
            height: 100%;
            background-color: #f4f4f4;
            border-right: 1px solid #ccc;
            padding-top: 20px;
            box-shadow: 2px 0 5px rgba(0,0,0,0.1);
            transition: left 0.3s ease;
            z-index: 2000;
        }

        #sidebar h2 {
            text-align: center;
            margin-bottom: 20px;
            color: #333;
        }

        #sidebar a {
            display: block;
            padding: 12px;
            text-decoration: none;
            color: #333;
            border-bottom: 1px solid #ddd;
            transition: background-color 0.3s;
        }

        #sidebar a:hover {
            background-color: #ddd;
        }
         /* ä¸»å…§å®¹ */
        #main-content {
            transition: margin-left 0.3s ease;
            padding: 20px;
        }

        /* å´é‚Šæ¬„æŒ‰éˆ• */
        #sidebar-btn {
            position: fixed;
            top: 40px;
            left: 0;
            background-color: #333;
            color: white;
            padding: 10px;
            cursor: pointer;
            border-radius: 0 5px 5px 0;
            transition: left 0.3s ease;
            z-index: 2100;
        }

        /* hover æ™‚å±•é–‹å´é‚Šæ¬„ä¸¦æ¨å‹•ä¸»å…§å®¹ */
        #sidebar-btn:hover + #sidebar,
        #sidebar:hover {
            left: 0;
        }

        #sidebar-btn:hover ~ #main-content,
        #sidebar:hover ~ #main-content {
            margin-left: 200px;
        }

        /* è¡¨æ ¼æ¨£å¼ */
        table th,
        table td {
        border: 1px solid var(--theme-table-border);
        padding: 8px;
        text-align: center;
        vertical-align: middle;
        white-space: nowrap;
        }
        table th {
            background-color: var(--theme-table-header-bg);
            color: var(--theme-text);
        }

        /* é›»é‡ */
        .battery-display {
        position: absolute;
        top: 0;
        right: 50px; /* å¯ä¾éœ€æ±‚å¾®èª¿è·é›¢ */
        font-size: 14px;
        color: #007b00;
        }
        .battery-watch {
        position: absolute;
        top: 5;
        right: 50px; /* å¯ä¾éœ€æ±‚å¾®èª¿è·é›¢ */
        font-size: 14px;
        color: #007b00;
        }
        .header-title {
        position: relative;  /* è®“ .battery-display çš„ absolute åƒè€ƒé€™å€‹å®¹å™¨ */
        text-align: center;
        }
        /* ä»Šæ—¥æ¶ˆè€—è³‡è¨Š */
        .summary-text {
        font-size: 18px;
        margin-bottom: 20px;
        color: #d39052;
        }
        /* å§¿æ…‹åœ–è¡¨å¤–æ¡† */
        .chart-container {
            position: relative; 
            width: 100%;
            max-width: 820px; 
            margin: 20px auto;
            background: #fdfdfd;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        /* åˆ†é å®¹å™¨ */
        #macTabs {
        display: flex;
        margin-bottom: 16px;
        padding-left: 8px;
        overflow-x: auto;
        }
        /* åˆ†é æŒ‰éˆ•ï¼ˆæœªé¸å–ç‹€æ…‹ï¼‰ */
        .mac-tab {
        padding: 8px 16px;
        background: #e4e9ec;
        color: var(--theme-text);
        border: none;
        border-radius: 12px 12px 0 0;
        border-bottom: none;
        border-radius: 8px 8px 0 0;
        margin-right: 6px;
        height: 45px;
        cursor: pointer;
        font-weight: bold;
        transition: background-color 0.2s ease, box-shadow 0.2s ease;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .mac-tab:hover {
        background:#d3d7dc;   /* æ»‘é¼ ç§»ä¸Šå»è®Šæ·ºç° */
        }
        /* åˆ†é æŒ‰éˆ•ï¼ˆé¸å–ç‹€æ…‹ï¼‰ */
        .mac-tab.active {
        background: var(--theme-section);
        border-color: #aaaaaa;
        border-bottom: 2px solid #ffffff;
        height: 45px;
        box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        }
        /* å³éµé¸å–® */
        .custom-context-menu {
            position: absolute;
            background: white;
            border: 1px solid #ccc;
            box-shadow: 2px 2px 6px rgba(0, 0, 0, 0.2);
            z-index: 9999;
            padding: 8px 12px;
            cursor: pointer;
            display: none;
            border-radius: 4px;
            font-size: 14px;
        }
        .custom-context-menu:hover {
            background-color: #f5f5f5;
        }
        /* loading æ¨£å¼ */
        body.loading {
            cursor: wait;
        }
        .chart-container.loading::after {
            content: 'è¼‰å…¥ä¸­...';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #888;
            background: rgba(255,255,255,0.8);
            padding: 10px 20px;
            border-radius: 5px;
        }
 
    </style>
</head>
<body>
    
    <div id="sidebar-container"></div>
    <script src="/static/js/sidebar.js"></script>


    <div class="container">
        <div class="header-title">
            <h1>IMU å§¿æ…‹æ•¸æ“šç›£æ¸¬</h1>
        </div>
        <div style="position: relative;">
            <span class="battery-display" id="safe_battery">å¹³å®‰ç¬¦é›»é‡ï¼š--%</span>
            <p>æ¯ 1 ç§’è‡ªå‹•æ›´æ–°æ•¸æ“š      æœ€å¾Œæ›´æ–°æ™‚é–“ï¼š<span id="lastUpdateTime">--</span></p>
            <span class="battery-watch" id="band_battery">æ‰‹ç’°é›»é‡ï¼š--%</span>

        </div>

        <div style="margin-bottom: 20px;">
            <label for="macSelector">é¸æ“‡è£ç½®ï¼š</label>
            <select id="macSelector">
                <option disabled selected>è¼‰å…¥ä¸­...</option>
            </select>
            <button onclick="addSelectedMacTab()">â• åŠ å…¥è£ç½®</button>
    </div>

    <div id="macTabs" class="mac-tabs-wrapper"></div>
        <!-- åˆ†é  + æ•¸æ“šå€å¡Š -->
    <div class="dashboard-body">
        <div class="data-section">

        <h2>æœ€æ–°æ•¸æ“š</h2>
        <div style="overflow-x: auto;">
            <table class="table table-bordered" id="dataDisplay">
                <thead>
                    <tr>
                      <th rowspan="2">æ™‚é–“</th>
                      <!-- <th rowspan="2">è¨­å‚™ MAC</th> -->
                      <th rowspan="2">å§¿æ…‹ç‹€æ…‹</th>
                      <th rowspan="2">Roll (ç¿»æ»¾)</th>
                      <th rowspan="2">Pitch (ä¿¯ä»°)</th>
                      <th rowspan="2">Yaw (åæ“º)</th>
                      <th colspan="3">åŠ é€Ÿåº¦ (g)</th>
                      <th rowspan="2">ç¸½åŠ é€Ÿåº¦ (g)</th>
                      <th colspan="3">ç£åŠ›</th>
                      <th rowspan="2">ç¸½ç£åŠ›</th>
                    </tr>
                    <tr>
                      <th>X</th>
                      <th>Y</th>
                      <th>Z</th>
                      <th>X</th>
                      <th>Y</th>
                      <th>Z</th>
                    </tr>
                  </thead>
            <tbody>
            </tbody>
        </table>
        </div>

        <div style="overflow-x: auto;">
        <h2 style="margin-top: 30px;">ç”Ÿç†æ•¸æ“š</h2>
        <p class="summary-text">
            ä»Šæ—¥æ¶ˆè€— ç†±é‡ï¼š<span id="Calories">--</span> å¤§å¡ /
            æ­¥æ•¸ï¼š<span id="Step">--</span> æ­¥ /
            è·é›¢ï¼š<span id="Mileage">--</span> å…¬é‡Œ
        </p>
        <table id="environmentDataDisplay">
            <thead>
                <tr>
                    <th>æ™‚é–“æˆ³</th>
                    <th>å¿ƒç‡ (æ¬¡/åˆ†é˜)</th>
                    <th>è¡€å£“</th>
                    <th>è¡€æ°§</th>
                    <th>é«”æº« (Â°C)</th>
                </tr>
            </thead>
            <tbody>
            </tbody>
        </table>
        </div>

        <h2 style="margin-top: 30px;">å‹•æ…‹åˆ†æ</h2>
        <div>
            <label for="timeWindowSelector" style="margin-left: 20px;">é¡¯ç¤ºæ™‚é–“å€é–“ï¼š</label>
            <select id="timeWindowSelector">
                <option value="60">è¿‘ 1 åˆ†é˜</option>
                <option value="300">è¿‘ 5 åˆ†é˜</option>
                <option value="600">è¿‘ 10 åˆ†é˜</option>
                <option value="1800">è¿‘ 30 åˆ†é˜</option>
                <option value="3600">è¿‘ 1 å°æ™‚</option>
                <option value="18000">è¿‘ 5 å°æ™‚</option>
                <option value="36000">è¿‘ 10 å°æ™‚</option>
                <option value="86400">è¿‘ 24 å°æ™‚</option>
            </select>
          </div>
        <div class="chart-container">
        <div style="width: 100%; height: 400px;">
            <canvas id="postureTimelineChart"></canvas>
        </div>
    </div>

    <script>
        // Chart å¯¦ä¾‹è®Šæ•¸
        let postureTimelineChart;

        const postureHistory = {};     // âœ… æ¯å€‹ MAC ä¸€ä»½è³‡æ–™
        const lastTimestamps = {};     // âœ… æ¯å€‹ MAC ä¸€ä»½æ™‚é–“é»

        // å®šç¾©æ¯å€‹å§¿æ…‹ç‹€æ…‹çš„é¡è‰² (1-8) å’Œæ–‡å­—æè¿°
        // æ³¨æ„: é€™è£¡çš„å§¿æ…‹æ–‡å­—èˆ‡æ‚¨çš„ç¬¬ä¸€å€‹å•é¡Œä¸­æä¾›çš„æœ‰äº›ä¸åŒï¼Œæˆ‘æ²¿ç”¨äº†æ‚¨ç¾åœ¨ä»£ç¢¼ä¸­çš„å®šç¾©ã€‚
        // å¦‚æœéœ€è¦ï¼Œè«‹æ ¹æ“šå¯¦éš›çš„å§¿æ…‹ç‹€æ…‹å®šç¾©é€²è¡Œèª¿æ•´ã€‚
        const postureColors = {
            '1': '#4CAF50', // ç¶ è‰² (åå§¿ - æ ¹æ“š postureText èª¿æ•´)
            '2': '#2196F3', // è—è‰² (ç«™ç«‹ - æ ¹æ“š postureText èª¿æ•´)
            '3': '#FFC107', // ç¥ç€è‰² (èººè‡¥)
            '4': '#FF9800', // æ©˜è‰² (å³èºº)
            '5': '#F44336', // ç´…è‰² (è·Œå€’)
            '6': '#9C27B0', // ç´«è‰² (è¶´è‡¥)
            '7': '#795548', // æ£•è‰² (å·¦èºº)
            '8': '#607D8B', // è—ç°è‰² (èµ°è·¯)
        };

        const postureText = {
            '1': 'åå§¿',
            '2': 'ç«™ç«‹',
            '3': 'èººè‡¥',
            '4': 'å³èºº',
            '5': 'è·Œå€’',
            '6': 'è¶´è‡¥',
            '7': 'å·¦èºº',
            '8': 'èµ°è·¯',
        };

        let activeMacTabs = [];      // å·²å»ºç«‹çš„åˆ†é è£ç½® MAC
        let currentActiveMac = null; // ç›®å‰é¡¯ç¤ºçš„è£ç½®


        // ---- ç‹€æ…‹å„²å­˜å·¥å…· ----
        function saveTabsState() {
        localStorage.setItem('activeMacTabs', JSON.stringify(activeMacTabs));
        localStorage.setItem('currentActiveMac', currentActiveMac ?? '');
        }

        function loadTabsState() {
        try {
            const tabs = JSON.parse(localStorage.getItem('activeMacTabs') || '[]');
            const current = localStorage.getItem('currentActiveMac') || null;
            if (Array.isArray(tabs)) activeMacTabs = tabs;
            currentActiveMac = current || (activeMacTabs[0] ?? null);
        } catch {}
        }


        // åµæ¸¬æ‰€æœ‰ Mac
        function MacSelector() {
            fetch('/api/mac_list') // å¾Œç«¯å›å‚³æ‰€æœ‰ MAC çš„ API
                .then(response => response.json())
                .then(macList => {
                    const selector = document.getElementById('macSelector');
                    selector.innerHTML = ''; // æ¸…ç©ºåŸæœ‰é¸é …

                    if (!Array.isArray(macList) || macList.length === 0) {
                        selector.innerHTML = '<option disabled>ç„¡è£ç½®å¯é¸æ“‡</option>';
                        return;
                    }

                    // å‹•æ…‹æ–°å¢é¸é …
                    macList.forEach((mac, index) => {
                        const option = document.createElement('option');
                        option.value = mac;
                        option.textContent = `è£ç½® ${index + 1} - ${mac}`;
                        selector.appendChild(option);
                    });

                    // å¦‚æœæœ¬ä¾†å°±æœ‰é¸å–ï¼Œæ²¿ç”¨ï¼›å¦å‰‡é¸ç¬¬ä¸€å€‹ä½†ä¸è¦æ¸…ç‹€æ…‹
                    if (currentActiveMac && macList.includes(currentActiveMac)) {
                        selector.value = currentActiveMac;
                    } else {
                        currentActiveMac = macList[0];
                        saveTabsState();
                    }
                    })
                    
                .catch(error => {
                    console.error('å–å¾— MAC æ¸…å–®å¤±æ•—:', error);
                    const selector = document.getElementById('macSelector');
                    selector.innerHTML = '<option disabled>è¼‰å…¥å¤±æ•—</option>';
                });
        }

        //  è¼‰å…¥æ‰€æœ‰ MAC è£ç½®é€²é¸å–®
        async function MacListDropdown() {
            try {
                const res = await fetch('/api/mac_list');
                const macList = await res.json();

                const dropdown = document.getElementById('macSelector');
                dropdown.innerHTML = ''; // æ¸…ç©º

                macList.forEach(mac => {
                    const option = document.createElement('option');
                    option.value = mac;
                    option.textContent = mac;
                    dropdown.appendChild(option);
                });
            } catch (err) {
                console.error('ç„¡æ³•è¼‰å…¥ MAC æ¸…å–®:', err);
            }
        }
        
        // Tab æ¨£å¼åˆ‡æ›
        function updateTabStyle() {
            document.querySelectorAll('#macTabs .mac-tab').forEach(tab => {
                tab.classList.toggle('active', tab.dataset.mac === currentActiveMac);
            });
        }

        // æ–°å¢ Mac è£ç½®åˆ†é 
        function addSelectedMacTab() {
            const dropdown = document.getElementById('macSelector');
            const selectedMac = dropdown.value;

            if (!(selectedMac in postureHistory)) {
                postureHistory[selectedMac] = [];    // åˆå§‹åŒ–å§¿æ…‹æ­·å²
                lastTimestamps[currentActiveMac] = null;    // åˆå§‹åŒ–æ™‚é–“
            }


            if (activeMacTabs.includes(selectedMac)) {
                alert('é€™å€‹è£ç½®å·²åŠ å…¥ï¼');
                return;
            }

            activeMacTabs.push(selectedMac);
            currentActiveMac = selectedMac;
            saveTabsState(); // <<<<<<<<<< æ–°å¢ï¼šå­˜æª”

            const tab = document.createElement('button');
            tab.textContent = `è£ç½® - ${selectedMac}`;
            tab.className = 'mac-tab';
            tab.dataset.mac = selectedMac;

            // å·¦éµåˆ‡æ›
            tab.onclick = () => {
                currentActiveMac = selectedMac;
                // å–å¾—å°æ‡‰è£ç½®çš„æ­·å²èˆ‡æ™‚é–“ï¼ˆå¦‚æœä¸å­˜åœ¨å°±åˆå§‹åŒ–ï¼‰
                postureHistory[currentActiveMac] ||= [];
                lastTimestamps[currentActiveMac] ||= null;
                saveTabsState(); 
                updateData();
                updatePostureChart();
                updateTabStyle();
            };

            // å³éµé»æ“Šï¼šå½ˆå‡ºåˆªé™¤ç¢ºèª
            tab.oncontextmenu = (e) => {
                e.preventDefault();
                showContextMenu(e.pageX, e.pageY, selectedMac, tab);
            };

            document.getElementById('macTabs').appendChild(tab);

            // ç¬¬ä¸€æ¬¡æ–°å¢å°±è‡ªå‹•é¡¯ç¤º
            updateData();
            updatePostureChart();
            updateTabStyle();
            checkMacTabsEmpty();
        }
        function checkMacTabsEmpty() {
            const tabContainer = document.getElementById('macTabs');
            const tabs = tabContainer.querySelectorAll('.mac-tab');
            if (tabs.length === 0) {
                tabContainer.style.display = 'none';
            } else {
                tabContainer.style.display = 'flex';
            }
        }
        // å³éµé»æ“Šåˆªé™¤è£ç½®
        function showContextMenu(x, y, mac, tabElement) {
            const menu = document.getElementById('contextMenu');
            menu.style.left = `${x}px`;
            menu.style.top = `${y}px`;
            menu.style.display = 'block';

            // å…ˆæ¸…é™¤èˆŠäº‹ä»¶
            const newMenu = menu.cloneNode(true);
            menu.parentNode.replaceChild(newMenu, menu);

            // åŠ å…¥åˆªé™¤é‚è¼¯
            newMenu.onclick = () => {
                activeMacTabs = activeMacTabs.filter(m => m !== mac);

                if (currentActiveMac === mac) {
                    currentActiveMac = activeMacTabs[0] || null;
                }
                saveTabsState();

                tabElement.remove();
                updateData();
                updatePostureChart();
                updateTabStyle();
                checkMacTabsEmpty(); // æª¢æŸ¥æ˜¯å¦è¦éš±è—å®¹å™¨
                newMenu.style.display = 'none';
            };
        }


        // åˆå§‹åŒ–åœ–è¡¨
        function PostureTimelineChart() {
            const ctx = document.getElementById('postureTimelineChart').getContext('2d');
            postureTimelineChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    datasets: [{
                        label: "å§¿æ…‹",
                        data: [],
                        backgroundColor: [],
                        borderSkipped: false
                    }]
                },
                    options: {
                        indexAxis: 'y', // ä½¿æ¢å½¢åœ–æ°´å¹³é¡¯ç¤º
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: {
                                type: 'time',
                                time: {
                                    unit: 'second', // é è¨­å–®ä½ï¼Œå¯¦éš›é¡¯ç¤ºæœƒç”± updatePostureChart æ±ºå®š
                                    tooltipFormat: 'HH:mm:ss',
                                    displayFormats: {
                                        second: 'HH:mm:ss',
                                        minute: 'HH:mm',
                                        hour: 'HH:mm'
                                    }
                                },
                            title: { display: true, text: 'æ™‚é–“' },
                            grid: {color: '#cccccc'}
                        },
                        y:  { 
                            type: 'category',
                            labels: ["åå§¿", "ç«™ç«‹", "èººè‡¥", "å³èºº", "å·¦èºº", "è¶´è‡¥", "èµ°è·¯", "è·Œå€’"],
                            offset: true, 
                            grid: {
                            color: '#cccccc',
                            drawTicks: false,       // âœ… ä¸ç•«å¤šé¤˜åˆ»åº¦
                            },
                            ticks: {
                                align: 'center',   // âœ… æ–‡å­—èˆ‡ bar å°é½Šåœ¨ä¸­é–“
                                crossAlign: 'center'
                            }
                        }
                    },
                    plugins: {
                        tooltip: {
                            callbacks: {
                                title: ctx => {
                                    const data = ctx[0].raw; 
                                    const start = luxon.DateTime.fromMillis(data.x[0]).toFormat('HH:mm:ss');
                                    const end = luxon.DateTime.fromMillis(data.x[1]).toFormat('HH:mm:ss');
                                    return `${start} - ${end}`;
                                },
                                label: function (context) {
                                    const data = context.raw;
                                    if (data && typeof data.duration === 'number') {
                                        let totalSeconds = Math.round(data.duration);

                                        const hours = Math.floor(totalSeconds / 3600);
                                        totalSeconds %= 3600;
                                        const minutes = Math.floor(totalSeconds / 60);
                                        const seconds = totalSeconds % 60;

                                        let result = 'å‹•ä½œæ™‚é–“ï¼š';
                                        if (hours > 0) result += `${hours} å°æ™‚ `;
                                        if (minutes > 0) result += `${minutes} åˆ† `;
                                        if (seconds > 0 || (hours === 0 && minutes === 0)) result += `${seconds} ç§’`;

                                        return result.trim();
                                    }

                                    return 'å‹•ä½œæ™‚é–“ï¼š--';
                                }
                            }
                        },
                        interaction: {
                            mode: 'nearest',
                            intersect: false,  // âœ… ä¸ä¸€å®šè¦é»åˆ°æ‰èƒ½è§¸ç™¼
                            axis: 'x',
                        },
                        hover: {
                            mode: 'nearest',
                            intersect: false,  // âœ… å¯ä»¥ hover é™„è¿‘å°±è§¸ç™¼
                        },
                        legend: {
                            display: true, 
                            position: 'bottom',
                            labels: {
                                generateLabels: chart => {
                                        return Object.keys(postureText).map(stateKey => ({
                                            text: postureText[stateKey] ,
                                            fillStyle: postureColors[stateKey] ,
                                            strokeStyle: postureColors[stateKey] ,
                                            pointStyle: 'rect'
                                        }));
                                }
                            }
                        }
                    },
                    animation: false
                }
            });
        }
        
        let latestDataBuffer = [];
        

        function Mac_device() {
            return currentActiveMac;
        }

        
        //æ•¸æ“šè™•ç†
        function updateData() {
            fetch('/api/latest_data') // å¾ Flask å¾Œç«¯ç²å–æ•¸æ“š
                .then(response => response.json())
                .then(data => {
                    const filteredData = data.filter(item => item.safe_Mac === Mac_device());

                    const dataTable = document.querySelector('#dataDisplay tbody');
                    dataTable.innerHTML = '';  

                    const physiologicalTable = document.querySelector('#environmentDataDisplay tbody');
                    physiologicalTable.innerHTML = '';

                    document.getElementById('lastUpdateTime').textContent = luxon.DateTime.now().toFormat('HH:mm:ss');

                    if (filteredData.length > 0) {
                        const latest = filteredData[filteredData.length - 1]; // å–å¾—æœ€æ–°ä¸€ç­†è³‡æ–™

                        // æ›´æ–°é›»é‡ã€ç†±é‡ã€æ­¥æ•¸ã€é‡Œç¨‹
                        document.getElementById('safe_battery').textContent = `å¹³å®‰ç¬¦é›»é‡ï¼š${latest.safe_battery ?? '--'}%`;
                        document.getElementById('band_battery').textContent = `æ‰‹ç’°é›»é‡ï¼š${latest.band_battery ?? '--'}%`;
                        document.getElementById('Calories').textContent = latest.Calories ?? '--';
                        document.getElementById('Step').textContent = latest.Step ?? '--';
                        document.getElementById('Mileage').textContent = latest.Mileage ?? '--'; 

                        // âœ… åªå–å‰ 10 ç­†
                        const maxRows = 10;
                        const latestData = filteredData.slice(0 ,maxRows);

                    latestData.forEach(item => {

                        // åœ¨è¡¨æ ¼ä¸­é¡¯ç¤ºæœ€æ–°çš„ IMU æ•¸æ“š
                        // è¡¨æ ¼ 1: æœ€æ–°æ•¸æ“š
                        const row = dataTable.insertRow();
                        row.insertCell().textContent = item.timestamp;
                        // row.insertCell().textContent = item.safe_Mac ?? '';
                        row.insertCell().textContent = postureText[String(item.Posture_state)] || postureText['unknown'];
                        row.insertCell().textContent = (typeof item.roll16 === 'number' ? (item.roll16*100).toFixed(1) + 'Â°' : '');
                        row.insertCell().textContent = (typeof item.pitch16 === 'number' ? (item.pitch16*100).toFixed(1) + 'Â°'  : '');
                        row.insertCell().textContent = (typeof item.yaw16 === 'number' ? (item.yaw16*100).toFixed(1) + 'Â°' : '');
                        row.insertCell().textContent = (typeof item.ACC_X === 'number' ? item.ACC_X.toFixed(4) + ' g' : '');
                        row.insertCell().textContent = (typeof item.ACC_Y === 'number' ? item.ACC_Y.toFixed(4) + ' g' : '');
                        row.insertCell().textContent = (typeof item.ACC_Z === 'number' ? item.ACC_Z.toFixed(4) + ' g' : '');
                        row.insertCell().textContent = (typeof item.ACC_total === 'number' ? item.ACC_total.toFixed(4) + ' g' : '');
                        row.insertCell().textContent = (typeof item.MAG_X === 'number' ? Math.round(item.MAG_X) + '' : '');
                        row.insertCell().textContent = (typeof item.MAG_Y === 'number' ? Math.round(item.MAG_Y) + '' : '');
                        row.insertCell().textContent = (typeof item.MAG_Z === 'number' ? Math.round(item.MAG_Z) + '' : '');
                        row.insertCell().textContent = (typeof item.MAG_total === 'number' ? Math.round(item.MAG_total) + '' : '');

                        // è¡¨æ ¼ 2: ç”Ÿç†æ•¸æ“š
                        const environmentRow = physiologicalTable.insertRow(); 
                        environmentRow.insertCell().textContent = item.timestamp;
                        environmentRow.insertCell().textContent = (typeof item.HR === 'number' ? Math.round(item.HR) + 'bpm': '');
                        environmentRow.insertCell().textContent = (typeof item.Bloodpressure_SBP === 'number' && typeof item.Bloodpressure_DBP === 'number') ? `${Math.round(item.Bloodpressure_SBP)} / ${Math.round(item.Bloodpressure_DBP)}` : '';
                        environmentRow.insertCell().textContent = (typeof item.Blood_oxygen === 'number' ? Math.round(item.Blood_oxygen) + '%': '');
                       
                        //æº«åº¦æ•¸æ“š
                        let temperatureValue = item.Temperature;
                        if (typeof temperatureValue === 'string') {
                            const parsed = parseFloat(temperatureValue);
                            temperatureValue = Number.isFinite(parsed) ? parsed : null;
                        }
                        environmentRow.insertCell().textContent = (typeof temperatureValue === 'number' && !isNaN(temperatureValue)) ? `${temperatureValue.toFixed(1)}Â°C` : '';

                    });
                }

            })
                .catch(error => {
                    console.error('ç²å–æ•¸æ“šå¤±æ•—:', error);
                });
        }

        // å§¿æ…‹æ™‚é–“å–®ä½æ›ç®—
        // function normalizeTimestamp(ts) {
        //     ts = Number(ts);
        //     if (ts < 1e12) { // 10ä½æ•¸ â†’ ç§’
        //         return ts * 1000;
        //     }
        //     return ts; // å·²ç¶“æ˜¯æ¯«ç§’
        // }
        function normalizeTimestamp(ts) {
            if (!ts) return null;
            if (typeof ts === 'string') {
                ts = Date.parse(ts);  // å­—ä¸²è½‰æ¯«ç§’
            }
            ts = Number(ts);
            if (!Number.isFinite(ts)) return null;
            if (ts < 1e12) return ts * 1000; // ç§’è½‰æ¯«ç§’
            return ts;
        }


        // let chartUpdatePausedUntil = 0;


        // // å§¿æ…‹åœ–è¡¨
        // async function updatePostureChart() {
        //     try {
        //         const timeWindowSeconds = Number(document.getElementById('timeWindowSelector').value); 
        //         const currentTime = luxon.DateTime.now();
        //         const minTime = currentTime.minus({ seconds: timeWindowSeconds });
        //         const minMs = minTime.toMillis();

        //         // å¸¶ä¸Šç›®å‰é¸åˆ°çš„ MAC
        //         const minutes = Math.ceil(timeWindowSeconds / 60); // ğŸ”¹ æ–°å¢ï¼šå‹•æ…‹ minutes
        //         const mac = Mac_device();
        //         let postureChange;

        //         //if (postureCache[mac]) {
        //         //    postureChange = postureCache[mac];
        //         //    console.log("âœ… ä½¿ç”¨å¿«å–è³‡æ–™ï¼š", postureChange.length);
        //         //} else {
        //             // const url = `/api/history_posechart?minutes=${minutes}&mac=${encodeURIComponent(mac)}`;
        //             const url = `/api/all_history_posechart?hours=1&mac=${encodeURIComponent(mac)}`;
        //             const response = await fetch(url);
        //             postureChange = await response.json();

        //             postureCache[mac] = postureChange;
        //             console.log("ğŸ“¡ å¾å¾Œç«¯æŠ“è³‡æ–™ï¼š", postureChange.length);
        //         //}

        //         // æª¢æŸ¥è³‡æ–™å‹æ…‹èˆ‡é•·åº¦
        //         if (!Array.isArray(postureChange) || postureChange.length === 0) {
        //             console.warn("âš  æ²’æœ‰è³‡æ–™");
        //             return;
        //         }

        //         // éæ¿¾ MAC
        //         let postureChanges = mac 
        //             ? postureChange.filter(s => s.safe_Mac === mac)
        //             : postureChange; // ğŸ”¹ åŸæœ¬æ˜¯ postureChangesRawï¼ˆé€™è£¡åŸæœ¬æœƒå ±éŒ¯ï¼Œä¿®æ­£ç‚º postureChangeï¼‰

        //         if (postureChanges.length === 0) {
        //             console.warn("âš  æŒ‡å®š MAC ç„¡è³‡æ–™");
        //             return;
        //         }

        //         // æ™‚é–“å–®ä½ä¿®æ­£ (ç¢ºä¿æ˜¯æ¯«ç§’)
        //         postureChanges = postureChanges.filter(s => {
        //             const startMs = normalizeTimestamp(s.startTime);
        //             const endMs = normalizeTimestamp(s.endTime ?? s.startTime);

        //             // âœ… åªè¦ segment æœ‰ã€Œä»»ä½•ä¸€éƒ¨åˆ†ã€è½åœ¨ [minMs, currentTime] ä¹‹é–“å°±ä¿ç•™
        //             return endMs >= minMs && startMs <= currentTime.toMillis();
        //         });

        //         if (postureChanges.length === 0) {
        //             console.warn("âš  éæ¿¾å¾Œæ²’è³‡æ–™ï¼Œæ”¹ç”¨å…¨éƒ¨è³‡æ–™");
        //             postureChanges = postureChange.map(s => ({
        //                 ...s,
        //                 startTime: normalizeTimestamp(s.startTime), // ğŸ”¹ é¿å… fallback æ™‚é‚„æ˜¯ç§’
        //                 endTime: normalizeTimestamp(s.endTime ?? s.startTime)
        //             }));
        //         }


        //         const history = postureHistory[currentActiveMac] = [];

        //         // æŠŠæ–°è³‡æ–™è½‰æ›æˆ segments
        //         const newSegments = [];
        //         let last = null;
        //         postureChanges.forEach(seg => {
        //             const state = String(seg.state);
        //             const startMs = normalizeTimestamp(seg.startTime); // ğŸ”¹ ç¢ºä¿æ˜¯æ¯«ç§’
        //             const endMs   = normalizeTimestamp(seg.endTime ?? seg.startTime);
        //             if (!Number.isFinite(startMs) || !Number.isFinite(endMs)) return;

        //             const MAX_GAP = 60 * 1000; // 3 åˆ†é˜

        //             if (last && last.state === state && startMs - last.endTime <= MAX_GAP) {
        //                 // last.endTime = Math.max(last.endTime, endMs);
        //                 last.endTime = endMs;
        //             } else {
        //                 last = { state, startTime: startMs, endTime: endMs };
        //                 history.push(last);
        //             }
        //         });

        //         // ğŸ”¹ åˆä½µæ–°èˆŠè³‡æ–™ï¼ˆé¿å…é‡è¤‡ï¼‰
        //         newSegments.forEach(seg => {
        //             const exists = history.find(h => 
        //                 h.state === seg.state && 
        //                 Math.abs(h.startTime - seg.startTime) < 1000 &&
        //                 Math.abs(h.endTime - seg.endTime) < 1000
        //             );
        //             if (!exists) history.push(seg);
        //         });

        //         // ğŸ”¹ ç¢ºä¿ä¾æ™‚é–“æ’åº
        //         history.sort((a, b) => a.startTime - b.startTime);

        //         // å»ºç«‹ dataset
        //         const dataset = {
        //             label: "å§¿æ…‹",
        //             backgroundColor: [],
        //             data: [],
        //             borderSkipped: false,
        //             barPercentage: 0.6,
        //             categoryPercentage: 0.8,
        //             barThickness: 30,
        //             parsing: { xAxisKey: "x", yAxisKey: "y" },
        //         };

        //         history.forEach(segment => {
        //             const label = postureText[segment.state] || "æœªçŸ¥";
        //             const color = postureColors[segment.state] || 'gray';
        //             dataset.data.push({ 
        //                 x: [segment.startTime, segment.endTime], 
        //                 y: label ,
        //                 duration: (segment.endTime - segment.startTime) / 1000  // å–®ä½ï¼šç§’
        //             });
        //             dataset.backgroundColor.push(color);
        //         });

        //         // postureTimelineChart.data.datasets[0] = dataset;
        //         const chartDataset = postureTimelineChart.data.datasets[0];
        //         chartDataset.data = dataset.data;
        //         chartDataset.backgroundColor = dataset.backgroundColor;


        //         // è¨­å®šæ™‚é–“åˆ»åº¦
        //         let unit, stepSizeValue, timeFormat;
        //         if (timeWindowSeconds <= 60) {
        //             unit = 'second'; stepSizeValue = 10; timeFormat = 'HH:mm:ss';
        //         } else if (timeWindowSeconds <= 600) {
        //             unit = 'minute'; stepSizeValue = 1; timeFormat = 'HH:mm';
        //         } else if (timeWindowSeconds <= 3600) {
        //             unit = 'minute'; stepSizeValue = 5; timeFormat = 'HH:mm';
        //         } else {
        //             unit = 'hour'; stepSizeValue = 1; timeFormat = 'HH:mm';
        //         }

        //         postureTimelineChart.options.scales.x = {
        //             type: 'time',
        //             time: { unit, stepSize: stepSizeValue, displayFormats: { [unit]: timeFormat }, tooltipFormat: timeFormat },
        //             min: minMs,
        //             max: luxon.DateTime.now().toMillis(),
        //             grid: { display: true, color: '#cccccc', lineWidth: 1, drawTicks: true, drawBorder: false, drawOnChartArea: true },
        //             ticks: {
        //                 autoSkip: true,
        //                 stepSize: stepSizeValue,
        //                 callback: value => luxon.DateTime.fromMillis(value).toFormat(timeFormat)
        //             },
        //         };
        //         postureTimelineChart.options.scales.x.min = minMs;
        //         postureTimelineChart.options.scales.x.max = currentTime.toMillis();

        //         console.log("ğŸ“Š åœ–è¡¨æ™‚é–“ç¯„åœï¼š", luxon.DateTime.fromMillis(minMs).toFormat("HH:mm:ss"), "~", luxon.DateTime.now().toFormat("HH:mm:ss"));
        //         console.log("ğŸ“Š segment ç¯„åœï¼š", postureChanges.map(s => ({
        //         state: s.state,
        //         start: luxon.DateTime.fromMillis(s.startTime).toFormat("HH:mm:ss"),
        //         end: luxon.DateTime.fromMillis(s.endTime).toFormat("HH:mm:ss")
        //         })));


        //         postureTimelineChart.update('none');  // âœ… ç„¡å‹•ç•«æ›´æ–°
        //         // postureTimelineChart.update();

        //     } catch (error) {
        //         console.error("æŠ“å– API å¤±æ•—:", error);
        //     }
        // }

        // å…¨åŸŸå¿«å–ï¼šæ¯å€‹ MAC ä¸€ä»½
        const postureCache = {};    // key: MAC, value: é™£åˆ—ï¼ˆå®Œæ•´è³‡æ–™ï¼‰

        // å§¿æ…‹åœ–è¡¨
        async function updatePostureChart() {
            try {
                const timeWindowSeconds = Number(document.getElementById('timeWindowSelector').value); 
                const currentTime = luxon.DateTime.now();
                const minTime = currentTime.minus({ seconds: timeWindowSeconds });
                const minMs = minTime.toMillis();

                // å¸¶ä¸Šç›®å‰é¸åˆ°çš„ MAC
                const minutes = Math.ceil(timeWindowSeconds / 60); // ğŸ”¹ æ–°å¢ï¼šå‹•æ…‹ minutes
                const mac = Mac_device();
                let postureChange;

                // ğŸ”¹ æ”¹é€²ï¼šå¦‚æœæ˜¯ 24 å°æ™‚ï¼ŒæŠ“ 24hï¼›å¦å‰‡åªæŠ“ 1 å°æ™‚
                let url;
                if (timeWindowSeconds >= 86400) {
                    url = `/api/all_history_posechart?hours=24&mac=${encodeURIComponent(mac)}`;
                } else {
                    url = `/api/all_history_posechart?hours=1&mac=${encodeURIComponent(mac)}`;
                }

                const response = await fetch(url);
                postureChange = await response.json();

                postureCache[mac] = postureChange;
                console.log("ğŸ“¡ å¾å¾Œç«¯æŠ“è³‡æ–™ï¼š", postureChange.length);

                // æª¢æŸ¥è³‡æ–™å‹æ…‹èˆ‡é•·åº¦
                if (!Array.isArray(postureChange) || postureChange.length === 0) {
                    console.warn("âš  æ²’æœ‰è³‡æ–™");
                    return;
                }

                // éæ¿¾ MAC
                let postureChanges = mac 
                    ? postureChange.filter(s => s.safe_Mac === mac)
                    : postureChange;

                if (postureChanges.length === 0) {
                    console.warn("âš  æŒ‡å®š MAC ç„¡è³‡æ–™");
                    return;
                }

                // æ™‚é–“å–®ä½ä¿®æ­£ (ç¢ºä¿æ˜¯æ¯«ç§’)
                postureChanges = postureChanges.filter(s => {
                    const startMs = normalizeTimestamp(s.startTime);
                    const endMs = normalizeTimestamp(s.endTime ?? s.startTime);
                    return endMs >= minMs && startMs <= currentTime.toMillis();
                });

                if (postureChanges.length === 0) {
                    console.warn("âš  éæ¿¾å¾Œæ²’è³‡æ–™ï¼Œæ”¹ç”¨å…¨éƒ¨è³‡æ–™");
                    postureChanges = postureChange.map(s => ({
                        ...s,
                        startTime: normalizeTimestamp(s.startTime),
                        endTime: normalizeTimestamp(s.endTime ?? s.startTime)
                    }));
                }

                const history = postureHistory[currentActiveMac] = [];
                let last = null;

                postureChanges.forEach(seg => {
                    const state = String(seg.state);
                    const startMs = normalizeTimestamp(seg.startTime);
                    const endMs   = normalizeTimestamp(seg.endTime ?? seg.startTime);
                    if (!Number.isFinite(startMs) || !Number.isFinite(endMs)) return;

                    const MAX_GAP = 60 * 1000; // 1 åˆ†é˜ gap è¦–ç‚ºåŒä¸€æ®µ
                    if (last && last.state === state && startMs - last.endTime <= MAX_GAP) {
                        last.endTime = endMs;
                    } else {
                        last = { state, startTime: startMs, endTime: endMs };
                        history.push(last);
                    }
                });

                history.sort((a, b) => a.startTime - b.startTime);

                const dataset = {
                    label: "å§¿æ…‹",
                    backgroundColor: [],
                    data: [],
                    borderSkipped: false,
                    barPercentage: 0.6,
                    categoryPercentage: 0.8,
                    barThickness: 30,
                    parsing: { xAxisKey: "x", yAxisKey: "y" },
                };

                history.forEach(segment => {
                    const label = postureText[segment.state] || "æœªçŸ¥";
                    const color = postureColors[segment.state] || 'gray';
                    dataset.data.push({ 
                        x: [segment.startTime, segment.endTime], 
                        y: label,
                        duration: (segment.endTime - segment.startTime) / 1000
                    });
                    dataset.backgroundColor.push(color);
                });

                const chartDataset = postureTimelineChart.data.datasets[0];
                chartDataset.data = dataset.data;
                chartDataset.backgroundColor = dataset.backgroundColor;

                // è¨­å®šæ™‚é–“åˆ»åº¦
                let unit, stepSizeValue, timeFormat;
                if (timeWindowSeconds <= 60) {
                    unit = 'second'; stepSizeValue = 10; timeFormat = 'HH:mm:ss';
                } else if (timeWindowSeconds <= 600) {
                    unit = 'minute'; stepSizeValue = 1; timeFormat = 'HH:mm';
                } else if (timeWindowSeconds <= 3600) {
                    unit = 'minute'; stepSizeValue = 5; timeFormat = 'HH:mm';
                } else {
                    unit = 'hour'; stepSizeValue = 1; timeFormat = 'HH:mm';
                }

                postureTimelineChart.options.scales.x = {
                    type: 'time',
                    time: { unit, stepSize: stepSizeValue, displayFormats: { [unit]: timeFormat }, tooltipFormat: timeFormat },
                    min: minMs,
                    max: currentTime.toMillis(),
                    grid: { display: true, color: '#cccccc', lineWidth: 1, drawTicks: true, drawBorder: false, drawOnChartArea: true },
                    ticks: {
                        autoSkip: true,
                        stepSize: stepSizeValue,
                        callback: value => luxon.DateTime.fromMillis(value).toFormat(timeFormat)
                    },
                };

                postureTimelineChart.options.scales.x.min = minMs;
                postureTimelineChart.options.scales.x.max = currentTime.toMillis();

                console.log("ğŸ“Š åœ–è¡¨æ™‚é–“ç¯„åœï¼š", luxon.DateTime.fromMillis(minMs).toFormat("HH:mm:ss"), "~", currentTime.toFormat("HH:mm:ss"));
                console.log("ğŸ“Š segment ç¯„åœï¼š", postureChanges.map(s => ({
                    state: s.state,
                    start: luxon.DateTime.fromMillis(s.startTime).toFormat("HH:mm:ss"),
                    end: luxon.DateTime.fromMillis(s.endTime).toFormat("HH:mm:ss")
                })));

                postureTimelineChart.update('none');  

            } catch (error) {
                console.error("æŠ“å– API å¤±æ•—:", error);
            }
        }


        document.addEventListener('DOMContentLoaded', () => {
            PostureTimelineChart(); // åˆå§‹åŒ–åœ–è¡¨çµæ§‹
            loadTabsState(); // <<<<<< å…ˆè®€æœ¬æ©Ÿç‹€æ…‹

            const theme = {
                '--theme-bg': '#f6f3e8',
                '--theme-text': '#333333',
                '--theme-tab-bg': '#f6f3e8',
                '--theme-tab-active-bg': '#ffffff',
                '--theme-container-bg': '#fbf9f3',
                '--theme-table-header-bg': '#f0dda4'
            };
            setTheme(theme); // âœ… å¥—ç”¨è®Šæ•¸

            // ä¾ç…§å„²å­˜çš„ tabs é‡å»º UI
            const tabsWrap = document.getElementById('macTabs');
            activeMacTabs.forEach(mac => {
                const tab = document.createElement('button');
                tab.textContent = `è£ç½® - ${mac}`;
                tab.className = 'mac-tab';
                tab.dataset.mac = mac;
                tab.onclick = () => {
                    currentActiveMac = mac;
                    saveTabsState(); // <<<<<< å­˜æª”
                    postureHistory[mac] ||= [];
                    lastTimestamps[mac] = lastTimestamps[mac] ?? null;
                    updateData();
                    updatePostureChart();
                    updateTabStyle();
                };
                tab.oncontextmenu = (e) => {
                    e.preventDefault();
                    showContextMenu(e.pageX, e.pageY, mac, tab);
                };
                tabsWrap.appendChild(tab);
            });
            updateTabStyle(); // æ›´æ–°åˆ†é æ¨£å¼ï¼ˆç¢ºä¿ active ç‹€æ…‹æ­£ç¢ºï¼‰

            MacSelector(); // åªè² è²¬æ›´æ–°ä¸‹æ‹‰é¸å–®           
            checkMacTabsEmpty();
            MacListDropdown(); // âœ… è¼‰å…¥ä¸‹æ‹‰é¸å–®çš„è£ç½®æ¸…å–®

            // å¦‚æœæœ‰å·²é¸è£ç½®ï¼Œè®“ä¸‹æ‹‰é¸å–®é¡¯ç¤ºå®ƒ
            const dropdown = document.getElementById('macSelector');
            const setDropdownToActive = () => {
                if (currentActiveMac && [...dropdown.options].some(o => o.value === currentActiveMac)) {
                    dropdown.value = currentActiveMac;
                }
            };
            setTimeout(setDropdownToActive, 300);

            setInterval(updateData, 1000); // è¨­å®šæ¯ 1 ç§’æ›´æ–°æ•¸æ“šçš„é–“éš”

            let postureChartTimer = null;

            function scheduleChartUpdate() {
                const now = Date.now();
                if (now < chartUpdatePausedUntil) return;  // æš«åœä¸­ï¼Œä¸æ›´æ–°

                clearTimeout(postureChartTimer);
                postureChartTimer = setTimeout(() => {
                    updatePostureChart();
                }, 300); // å»¶é² 300ms æ›´æ–°ï¼Œé¿å…åˆ‡æ›å¤ªå¿«é€ æˆè¡çª
            }

            // ç•¶æ™‚é–“å€é–“é¸å–®æ”¹è®Šæ™‚æ›´æ–°åœ–è¡¨
            document.getElementById('timeWindowSelector').addEventListener('change', async (e) => {
                const selectedTime = e.target.value;
                localStorage.setItem('selectedTimeWindow', selectedTime);  // â† å„²å­˜åˆ° localStorage
                // updatePostureChart(); // åŸæœ¬çš„å‹•ä½œ
                const chartContainer = document.querySelector('.chart-container');
                chartContainer.classList.add('loading');

                try {
                    await updatePostureChart();
                } catch (error) {
                    console.error("æ›´æ–°åœ–è¡¨å¤±æ•—:", error);
                } finally {
                    chartContainer.classList.remove('loading');
                }
            });

            const savedTime = localStorage.getItem('selectedTimeWindow');
            if (savedTime) {
                const timeSelector = document.getElementById('timeWindowSelector');
                if ([...timeSelector.options].some(opt => opt.value === savedTime)) {
                    timeSelector.value = savedTime;
                }
            }

            // âœ… ç•¶ä½¿ç”¨è€…é¸æ“‡ä¸åŒ MAC è£ç½®æ™‚ï¼Œæ¸…ç©ºæ­·å²ä¸¦æ›´æ–°è³‡æ–™
            document.getElementById('macSelector').addEventListener('change', () => {
                currentActiveMac = document.getElementById('macSelector').value;
                saveTabsState(); // <<<<<< å­˜æª”
                updateData();
                updatePostureChart();
                updateTabStyle();
            });

            // é»æ“Šå…¶ä»–åœ°æ–¹éš±è—å³éµé¸å–®
            document.addEventListener('click', () => {
                document.getElementById('contextMenu').style.display = 'none';
            });

            // åœ–è¡¨æ›´æ–°
            // setInterval(() => {
            //     updatePostureChart()
            //         .catch(err => console.error("è‡ªå‹•æ›´æ–°åœ–è¡¨å¤±æ•—", err))
            // }, 1000);  // æ¯ 1 ç§’æ›´æ–°ä¸€æ¬¡
            // åœ–è¡¨åˆå§‹åŒ–ï¼šé€²ä¾†æ™‚å…ˆæŠ“ä¸€æ¬¡å®Œæ•´ 24 å°æ™‚
            updatePostureChart();

            let lastKnownTimestamp = 0;

            setInterval(async () => {
                try {
                    const res = await fetch('/api/last_timestamp');
                    const { last_ts } = await res.json();
                    if (last_ts && last_ts > lastKnownTimestamp) {
                        console.log("âš¡ åµæ¸¬åˆ°æ–°è³‡æ–™ï¼Œæ›´æ–°åœ–è¡¨");
                        lastKnownTimestamp = last_ts;
                        updatePostureChart();  // æœ‰æ–°è³‡æ–™æ‰æ›´æ–°
                    }
                } catch (err) {
                    console.error("æª¢æŸ¥æœ€æ–°è³‡æ–™å¤±æ•—:", err);
                }
            }, 3000); // æ¯ 5 ç§’æª¢æŸ¥ä¸€æ¬¡


            // æ¯ç§’é‡ç¹ªä¸€æ¬¡åœ–è¡¨ï¼ˆç”¨å¿«å–è³‡æ–™ï¼Œä¸æ‰“ APIï¼‰
            setInterval(() => {
                if (currentActiveMac && postureCache[currentActiveMac]) {
                    // åªé‡ç¹ªï¼Œä¸é‡æ–° fetch
                    const history = postureCache[currentActiveMac];
                    const dataset = postureTimelineChart.data.datasets[0];
                    dataset.data = history.map(seg => ({
                        x: [seg.startTime, seg.endTime],
                        y: postureText[seg.state] || "æœªçŸ¥",
                        duration: (seg.endTime - seg.startTime) / 1000
                    }));
                    dataset.backgroundColor = history.map(seg => postureColors[seg.state] || 'gray');
                    postureTimelineChart.update('none');
                }
            }, 1000);

        });

    </script>

    <div id="contextMenu" class="custom-context-menu">åˆªé™¤è£ç½®</div>

</body>
</html> 